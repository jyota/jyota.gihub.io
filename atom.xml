<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom"><title>Jyota Snyder's portfolio site</title><link href="http://localhost:8080/atom.xml" rel="self" /><link href="http://localhost:8080" /><updated></updated><id>http://localhost:8080</id><author><name>@</name></author><entry><title>Josephus Problem</title><link href="http://localhost:8080/2017-09/post1.html" /><updated>2017-09-05T00:00:00</updated><id>http://localhost:8080/2017-09/post1.html</id><content type="html">&lt;p class=&quot;paragraph&quot;&gt;Working through some linked-list exercises in Sedgewick's Algorithms in C (3rd edition), I came across this fun problem called &lt;a href=&quot;https://en.wikipedia.org/wiki/Josephus_problem&quot;&gt;the Josephus Problem&lt;/a&gt;. The book described the problem and gave a linked-list solution using a typical linked-list structure in C, then as an exercise presented it such that the reader should solve it by representing the linked list in an array structure instead. Below is my solution for this as a gist.&lt;/p&gt;&lt;br /&gt;&lt;script src=&quot;https://gist.github.com/jyota/a2a0635f9d430088cd4bd95c5d8f7227.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;&lt;br /&gt;&lt;p class=&quot;paragraph&quot;&gt;I ran into a bug in the case of M = 1 and was initially going to simply return N in that scenario, but decided to try to really fix the code so the same procedure could be used for all values of M &gt; 0. I noticed I never handled the case where the first item in the array gets eliminated first, as I had initially set prev_item = 0 before the while loop began. To fix that, I set prev_item = N - 1 for every while loop, to ensure the correct 'leader' value would be printed once the linked-list became a cycle to itself for all cases M &gt; 0.&lt;/p&gt;</content></entry><entry><title>C# IEnumerable & IEnumerator</title><link href="http://localhost:8080/2017-08/post1.html" /><updated>2017-08-17T00:00:00</updated><id>http://localhost:8080/2017-08/post1.html</id><content type="html">&lt;p class=&quot;paragraph&quot;&gt;As I mentioned in the first post on this site, I've been brushing up on some computer science fundamentals, currently working through projects in the book The Elements of Computing Systems. I'm working on the project in chapter 06, which is to write an assembler program -- converting assembly language code to binary for the computing platform described in the book. It's been a while since I programmed in C#; .NET Core 2.0 was just released; Visual Studio Code has been out for a while; I wanted to try all those out, so this looked like a good opportunity to write the assembler using those (&lt;a href=&quot;https://github.com/jyota/nand2tetris/blob/master/projects/06/assembler/&quot;&gt;code is on Github&lt;/a&gt;).&lt;/p&gt;&lt;br /&gt;&lt;p class=&quot;paragraph&quot;&gt;One of the requirements for the assembler from the book that was interesting to me was to parse valid commands from an input file -- with a method called 'hasMoreCommands' that returns a boolean if any commands remain to be parsed, and another method called 'advance' that would read the next command from the input and make it the current command selected for parsing, but only if 'hasMoreCommands' method returns true. Since source code files could have comments or blank lines, I was considering: how do you know if the file really has more commands just based on the filestream? Perhaps the stream indicates another line is available in the file for reading, but that does not let us know if there is actually another command in the file or not.&lt;/p&gt;&lt;br /&gt;&lt;p class=&quot;paragraph&quot;&gt;Looking briefly online, it appeared at least one person solved this just by loading the entire file, filtering out the lines that were not parsed as commands, then iterating through those. Since these were usually relatively small text files, it seemed like a reasonable approach. However, I didn't feel good about reading the whole file into memory (even if lines were filtered while reading them), and then iterating through the valid lines again later to parse those into binary.&lt;/p&gt;&lt;br /&gt;&lt;p class=&quot;paragraph&quot;&gt;So I looked at using an approach I learned from a colleague while programming in Python, which was the use of a generator. Researching a bit about the C# way to do this, I found out about IEnumerable and IEnumerator which seemed to be similar to generators I had used in Python. I wrote a function returning IEnumerable that would read each line of the assembly source code file and yield only the lines that were determined to be valid commands.&lt;/p&gt;&lt;br /&gt;&lt;p class=&quot;paragraph&quot;&gt;Whenever the 'advance' method is called, it will call 'hasMoreCommands' as required by the book specification to check if another valid command can be retrieved from the file. In my implementation, the call to 'hasMoreCommands' would in turn call the C# MoveNext() command on the IEnumerator taken from the IEnumerable function used for reading/filtering/yielding valid commands from the file. The idea is that MoveNext() would move the IEnumerator to the next item, a valid command, if one existed. If MoveNext() succeeded, the current assembly command to parse would be set to be the IEnumerator's 'Current' value.&lt;/p&gt;&lt;br /&gt;&lt;p class=&quot;paragraph&quot;&gt;I felt like this was a cleaner and more functional way to parse valid commands from the file than to load it entirely into memory first and then iterate through a list of valid commands loaded fully in memory. With the approach I picked, there is no need to store all the valid assembly commands from the file in memory. Another benefit is in not needing to iterate through the all the lines again once they are read into memory; the lines are only iterated over once. Here's a &lt;a href=&quot;https://github.com/jyota/nand2tetris/blob/master/projects/06/assembler/Parser.cs&quot;&gt;link to the Parser module code&lt;/a&gt; if you want to check it out. By the way, using Visual Studio Code and C# on .NET Core has been a breeze and quite enjoyable. I plan to use these tools to finish whatever language agnostic projects remain from The Elements of Computing Systems book.&lt;/p&gt;&lt;br /&gt;</content></entry><entry><title>Reviewing computer science fundamentals</title><link href="http://localhost:8080/2017-07/post1.html" /><updated>2017-07-31T00:00:00</updated><id>http://localhost:8080/2017-07/post1.html</id><content type="html">&lt;p class=&quot;paragraph&quot;&gt;Although I have worked for about six years now programming and developing software, I really haven't thoroughly studied 'fundamental computer science.' I began programming on an old Tandy PC with 5-1/4 inch floppy disks in Basic on MS-DOS. Back then, it was just to try to make games I wanted to play. Then as a teenager, I got to use dial-up internet through my father's employer (a state university) and began learning more about hardware, software, code, and Linux.&lt;/p&gt;&lt;br /&gt;&lt;p class=&quot;paragraph&quot;&gt;Using Linux taught me a lot more about computers than I had known using MS-DOS and Windows. Also, I got to play around in the VAX/VMS environment provided when dialed up to the university. I began learning C programming in Linux to write some 'network utilities' (port scanners, proxy programs, and such). Also, I worked on tile based scrolling games in C. I tried my hand at developing GUI based applications for Windows around this time using C++ and Visual Basic, didn't get very far though.&lt;/p&gt;&lt;br /&gt;&lt;p class=&quot;paragraph&quot;&gt;So it sounds like I'm reminiscing here, and that's true. However, while programming all these things, building and learning about computers, and vaguely aware that 'if I do things certain ways, they are slower than other ways', I never dove into core concepts of computer science, and alas I chose other directions in college to study. I always looked at programming and computers as something I could just do, and it was more of a hobby.&lt;/p&gt;&lt;br /&gt;&lt;p class=&quot;paragraph&quot;&gt;Fast forward to about 6 years ago or so. I didn't really imagine at that point, that I'd end up employed as a software engineer, which is surprising to me because it seemed like it would have been natural for me to get into this field. Anyway, here we are today, and I've done some pretty cool things building software and doing 'data science.' Things that businesses find pretty valuable, I'd say, based on feedback I've gotten. Yet, I still wouldn't say I grasp deeply 'computer science fundamentals.'&lt;/p&gt;&lt;br /&gt;&lt;p class=&quot;paragraph&quot;&gt;What are 'computer science fundamentals?' I've heard it explained as being composed of a lot of things -- complexity theory, to algorithms, compiler design, automatons, etc. All these things I've read enough information about to get by, but now feel driven to learn more about. When I've looked up information about these things or ask colleagues, I hear so many different opinions, it's honestly really confusing. &lt;/p&gt;&lt;br /&gt;&lt;p class=&quot;paragraph&quot;&gt;Some say one really needs the full undergraduate degree in computer science to 'get it.' Another said just read 'Cracking the Coding Interview' and work through the problems in there. Then there a numerous book recommendations: Knuth's 'The Art of Computer Programming' series, Skiena's 'The Algorithm Design Manual', the CLRS 'Introduction to Algorithms', 'Algorithms in a Nutshell' (an O'Reilly book), Sedgewick &amp; Wayne's 'Algorithms', 'The Elements of Computing Systems', Stuarts' 'Understanding Computation', etc. Oh, and don't forget all the possible MOOC or open course lectures one could use to learn these things.&lt;/p&gt;&lt;br /&gt;&lt;p class=&quot;paragraph&quot;&gt;To me, it's information overload to try to decide what is best, especially with so many different answers. I've gotten through graduate school in college, so feel kind of done with the academic route at this point. So I've decided I'll pick from a few of the recommended things that seem likely to help me with where I'm at today, commit to those, and move forward with learning. The following is my self-appointed syllabus -- which I plan to supplement with appropriate lecture videos and other resources as seems useful. &lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;p class=&quot;paragraph&quot;&gt;Read and do the projects in 'The Elements of Computing Systems'.&lt;/p&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;&lt;p class=&quot;paragraph&quot;&gt;Read and work through 'The Algorithm Design Manual'.&lt;/p&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;&lt;p class=&quot;paragraph&quot;&gt;Read and work through 'Understanding Computation'.&lt;/p&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;&lt;p class=&quot;paragraph&quot;&gt;Read and work through 'The Structure and Interpretation of Computer Programs'.&lt;/p&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;&lt;p class=&quot;paragraph&quot;&gt;Read and work through 'Cracking the Coding Interview'.&lt;/p&gt;&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p class=&quot;paragraph&quot;&gt;Oh, and I'd already read through Cormen's 'Algorithms Unlocked' as sort of a 'primer' on algorithms a couple months ago. So, my primary goal is to learn hopefully a substantial amount of the computer science fundamentals I may have skipped over to this point in my life and career -- mostly for my own enjoyment and benefit. Although I haven't had any big issues with staying employed in this field so far, my hope is that a beneficial side-effect will be to increase my opportunities to work on interesting problems as a software engineer. &lt;a href=&quot;mailto:jyotas@integrated.pro&quot;&gt;Let me know&lt;/a&gt; if you've got any strong opinions about the approach I'm taking -- or for that matter, tips, warnings, and/or words of encouragement -- all are welcome. &lt;/p&gt;&lt;br /&gt;</content></entry></feed>