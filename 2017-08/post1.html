<!DOCTYPE html>
<html lang="en"><head><meta charset="utf-8"><meta content="width=device-width, initial-scale=1.0, user-scalable=yes" name="viewport"><title>Jyota Snyder's portfolio site - C# IEnumerable & IEnumerator</title><link href="/favicon.ico" rel="shortcut icon"><link href="/atom.xml" rel="alternate" title="C# IEnumerable &amp; IEnumerator" type="application/atom+xml"><link href="/css/prettify.css" rel="stylesheet" type="text/css"><link href="http://fonts.googleapis.com/css?family=Josefin+Sans" rel="stylesheet" type="text/css"><link href="/css/main.css" rel="stylesheet" type="text/css"><link href="/css/extra.css" rel="stylesheet" type="text/css"><link href="/css/smartphone.css" media="only screen and (max-device-width:480px)" rel="stylesheet" type="text/css"></head><body><div class="container"><header><h1><a href="/"><span class="first_char">C</span># IEnumerable & IEnumerator</a></h1><p><a href="/about.html">about me</a> | <a href="/projects.html">projects</a> | <a href="mailto:jyotas@integrated.pro">contact</a> | <a href="http://linkedin.com/in/jyota-snyder-40b193146">linkedin</a></p></header><article><div class="page-header"><h1 id="G__3560"><span>C</span># IEnumerable & IEnumerator<a class="dagger" href="#G__3560">&dagger;</a></h1><div class="tag"><ul></ul></div><p class="date">17 Aug 2017</p></div><div class="post"><p class="paragraph">As I mentioned in the first post on this site, I've been brushing up on some computer science fundamentals, currently working through projects in the book The Elements of Computing Systems. I'm working on the project in chapter 06, which is to write an assembler program -- converting assembly language code to binary for the computing platform described in the book. It's been a while since I programmed in C#; .NET Core 2.0 was just released; Visual Studio Code has been out for a while; I wanted to try all those out, so this looked like a good opportunity to write the assembler using those (<a href="https://github.com/jyota/nand2tetris/blob/master/projects/06/assembler/">code is on Github</a>).</p><br><p class="paragraph">One of the requirements for the assembler from the book that was interesting to me was to parse valid commands from an input file -- with a method called 'hasMoreCommands' that returns a boolean if any commands remain to be parsed, and another method called 'advance' that would read the next command from the input and make it the current command selected for parsing, but only if 'hasMoreCommands' method returns true. Since source code files could have comments or blank lines, I was considering: how do you know if the file really has more commands just based on the filestream? Perhaps the stream indicates another line is available in the file for reading, but that does not let us know if there is actually another command in the file or not.</p><br><p class="paragraph">Looking briefly online, it appeared at least one person solved this just by loading the entire file, filtering out the lines that were not parsed as commands, then iterating through those. Since these were usually relatively small text files, it seemed like a reasonable approach. However, I didn't feel good about reading the whole file into memory (even if lines were filtered while reading them), and then iterating through the valid lines again later to parse those into binary.</p><br><p class="paragraph">So I looked at using an approach I learned from a colleague while programming in Python, which was the use of a generator. Researching a bit about the C# way to do this, I found out about IEnumerable and IEnumerator which seemed to be similar to generators I had used in Python. I wrote a function returning IEnumerable that would read each line of the assembly source code file and yield only the lines that were determined to be valid commands.</p><br><p class="paragraph">Whenever the 'advance' method is called, it will call 'hasMoreCommands' as required by the book specification to check if another valid command can be retrieved from the file. In my implementation, the call to 'hasMoreCommands' would in turn call the C# MoveNext() command on the IEnumerator taken from the IEnumerable function used for reading/filtering/yielding valid commands from the file. The idea is that MoveNext() would move the IEnumerator to the next item, a valid command, if one existed. If MoveNext() succeeded, the current assembly command to parse would be set to be the IEnumerator's 'Current' value.</p><br><p class="paragraph">I felt like this was a cleaner and more functional way to parse valid commands from the file than to load it entirely into memory first and then iterate through a list of valid commands loaded fully in memory. With the approach I picked, there is no need to store all the valid assembly commands from the file in memory. Another benefit is in not needing to iterate through the all the lines again once they are read into memory; the lines are only iterated over once. Here's a <a href="https://github.com/jyota/nand2tetris/blob/master/projects/06/assembler/Parser.cs">link to the Parser module code</a> if you want to check it out. By the way, using Visual Studio Code and C# on .NET Core has been a breeze and quite enjoyable. I plan to use these tools to finish whatever language agnostic projects remain from The Elements of Computing Systems book.</p><br></div><p class="paragraph pager"><a href="/2017-09/post1.html">&laquo; Josephus Problem</a>&nbsp;&nbsp;|&nbsp;&nbsp;<a href="/">Top Page</a>&nbsp;&nbsp;|&nbsp;&nbsp;<a href="/2017-07/post1.html">Reviewing computer science fundamentals&nbsp;&raquo;</a></p></article><footer class="footer"><p class="right back_to_top"><a href="#">&uArr; Page Top</a></p><p>&copy; Jyota Snyder</p></footer></div><script src="/js/prettify.js" type="text/javascript"></script><script src="/js/lang-clj.js" type="text/javascript"></script><script src="/js/main.js" type="text/javascript"></script></body></html>